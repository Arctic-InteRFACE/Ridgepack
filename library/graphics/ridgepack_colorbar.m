function [hcb]=ridgepack_colorbar(cont,units,loglin,horiz,ref,colvals)

% ridgepack_colorbar - Generates a sophisticated colorbar in true color
%
% function [hcb]=ridgepack_colorbar(cont,units,loglin,horiz,ref,colvals)
%
% This function creates the colormap and draws a colorbar to the right
% of or underneath the plot. Units are added, and a factor of ten
% is also added if the number is less than 1 or greater than or
% equal to 1000.  The colormap and colorbar have several features
% that improve the style and readability of the plots, and ability
% to distinguish between values, which can be difficult using 
% standard matlab color scales. Note that it is assumed that the 
% data plotted on the axes to which this colorbar corresponds is 
% already indexed to the current colormap, even when data is plotted
% in true color.  The typical squence of calling is:
% 
% cmap=ridgepack_colormap(cont,ref,colors)
% [zindex,truecol]ridgepack_colorindex(z,cont,ref,mask)
% ... (functions for plotting data) ...
% ridgepack_colorbar(cont,units,loglin,horiz,ref)
%
% This generates the colormap, then obtains the true color array
% for plotting, then generates a color plot, then plots the colorbar.
%
% INPUT:
%
% cont    - color levels entered as a vector [C1,C2,...,CX].
%
% units   - units to be plotted on the colorbar (as string)
%
% Loglin  - 'linear' for linear color scaling, or for log scaling simply
%           enter any numeric value. (linear is the default)
%
% horiz   - 'horizontal' for colorbar along the bottom, 'vertical' for
%           colorbar on the right side of the plot. {vertical is default}
%
% ref     - reference point about which the color is centered, and, when
%           the minimum or maximum is equal to ref, all points below or 
%           above this value, respectively, are not filled with a color.
%           {zero is the default value}
%
% colvals - labels for each tick of the colorbar, if autogenerated labels
%           are not desired {optional} 
%
%
% OUTPUT:
%
% hcb	 - colorbar handle
%
% The only two inputs that are compulsory are cont and units, the
% others can be eliminated if need be to default to actual values.
% 
% Ridgepack Version 1.0
% Andrew Roberts, Naval Postgraduate School, March 2018 (afrobert@nps.edu)

global debug;
if debug; disp(['Entering ',mfilename,'...']); end

ht=get(gcf,'CurrentAxes');

interpreter=get(0,'DefaultTextInterpreter');
if strcmpi(interpreter,'latex')
 disp('Using Latex interpreter for colorbar');
end

% change to zbuffer
set(gcf,'renderer','zbuffer')
%set(gcf,'renderer','OpenGL')

% set defaults
if nargin<2; error('specify both cont and units'); end
if nargin<3; loglin='linear'; end
if nargin<4; horiz='vertical'; end
if nargin<5; ref=0.0; end

% sort cont in ascending numerical order, taking into account a single value
if isempty(cont)
  error('Cont is an empty vector');
elseif length(cont)<2
  disp('Contour levels should be at least two elements long'); 
  c1=cont(1); 
  cont=zeros(1, 3);
  cont(1)=c1-eps;
  cont(2)=c1;
  cont(3)=c1+eps;
end
cont=sort(cont);

% set tick marks
Ytick=zeros(1, length(cont));
Yticklabel=cont;
if nargin==6 & iscell(colvals)
 if length(colvals)~=length(cont)
  error('colvals length must equal the length of cont')
 else
  disp('Manually setting tick labels')
 end
elseif nargin==6
 error('Colvals must be a cell array')
end

% get figure position statistics
figpos=get(ht,'Position');
figout=get(ht,'OuterPosition');

% get colormap
cmap=colormap;

% Generate the colorbar axis and retrieve the limits
hcb=ridgepack_cbpos(ht,horiz);
if ishandle(hcb)
 if strcmp(horiz,'vertical')
  xlim=get(hcb,'xlim');
  ylim=get(hcb,'ylim');
  if figpos(3)>0.75
   maxticks=25;
  else
   maxticks=21;
  end
 elseif strcmp(horiz,'horizontal')
  xlim=get(hcb,'ylim');
  ylim=get(hcb,'xlim');
  if figpos(4)>0.75
   maxticks=17
  else
   maxticks=15;
  end
 else
  error('Colorbar orientation error')
 end
elseif ischar(hcb) && strcmp(hcb,'ColorbarDeleted')
 disp('No colorbar generation possible')
 return  
else
 error('Problem generating colorbar')
end


% Get fontsize of the axes
fontsize=get(hcb,'fontsize');

% Move over to work on colorbar axes
set(gcf,'CurrentAxes',hcb)

% Set tick labels and draw patches over the colorbar.  This is
% done for two reasons.  Firstly, for the case of a logarithmic 
% scale, the point here is to divide the scale logarithmically.
% Secondly, This fixes a glitch with printing a quantized colorbar
% to EPS using the normal matlab colorbar.
if isnumeric(loglin)
 if any(cont>0)
  pcont=log10(cont(cont>0));
  pcont=1+pcont-pcont(1); % scale with >0 exponents
  plength=abs(pcont(end)-pcont(1));
 else
  pcont=[];
  plength=0;
 end
 if any(cont<0)
  ncont=log10(abs(cont(cont<0)));
  ncont=-(1+ncont-ncont(end)); % scale with >0 exponents
  nlength=abs(ncont(end)-ncont(1));
 else
  ncont=[];
  nlength=0;
 end
 if nlength~=0 & plength~=0
  midlength=(plength+nlength)/(length(unique(round(ncont)))+length(unique(round(pcont)))-2);
 else
  midlength=0;
 end
 tcont=[ncont pcont];
 totallength=plength+nlength+midlength;

else

 tcont=cont;

end

for i=1:length(tcont);
 if isnumeric(loglin)
  if tcont(i)>0
   Ytick(i)=ylim(1)+diff(ylim)*(tcont(i)-tcont(length(ncont)+1)+nlength+midlength)/totallength;
  elseif tcont(i)<0
   Ytick(i)=ylim(1)+diff(ylim)*(tcont(i)-tcont(1))/totallength;
  else
   error('unable to process zero value for log colorbar - coding error')
  end
 else
  Ytick(i)=ylim(1)+(i-1)*diff(ylim)/(length(tcont)-1);
 end
 if i>1
   if strcmp(horiz,'vertical');
    hh=patch([xlim(1); xlim(1); xlim(2); xlim(2)],...
             [Ytick(i-1); Ytick(i); Ytick(i); Ytick(i-1)],...
             cmap(i-1,:),'Parent',hcb,'EdgeColor','none');
   elseif strcmp(horiz,'horizontal');
    hh=patch([Ytick(i-1); Ytick(i); Ytick(i); Ytick(i-1)],...
             [xlim(1); xlim(1); xlim(2); xlim(2)],...
             cmap(i-1,:),'Parent',hcb,'EdgeColor','none');
   end
 end
end


if isnumeric(loglin)

  % only allow tick marks at each change in order of magnitude
  % and at the reference point
  j=0;
  k=0;
  minortick=[];
  for i=1:length(Ytick);
    order=log10(abs(Yticklabel(i)));
    if order-fix(order)==0 | Yticklabel(i)==ref | i==1 | i==length(Ytick)
      j=j+1;
      newYTick(j)=Ytick(i);
      newYTicklabel(j)=Yticklabel(i);
    else
      k=k+1;
      minortick(k)=Ytick(i);
    end
  end
  Ytick=newYTick;
  Yticklabel=newYTicklabel;
  clear newYTick
  clear newYTicklabel

  % no power of ten required with units
  mult=[''];
  
else

 % thin the colorbar ticks to make it readable if need be
 if length(Ytick)>maxticks

   disp('Too many color categories: Thinning colorbar')

   if ref>=Yticklabel(end) | ref<=Yticklabel(1) 

    % case of ref off color scale
    centralcmapindex1=fix((length(cmap))/2)+1;
    centralcmapindex2=centralcmapindex1;

   else

    % case of grey space in colorscale or not
    centralcmapindex1=find(Yticklabel<=ref);
    centralcmapindex1=centralcmapindex1(end);
    centralcmapindex2=find(Yticklabel>=ref);
    centralcmapindex2=centralcmapindex2(1);

   end

   step=fix(length(cmap)/(maxticks-1))+1;

   startstep=centralcmapindex1-(maxticks-1)*step;
   endstep=centralcmapindex2+(maxticks-1)*step;

   if centralcmapindex1==centralcmapindex2
    cbindex=[startstep:step:endstep];
   else
    cbindex=[startstep:step:centralcmapindex1 centralcmapindex2:step:endstep];
   end
   cbindex=cbindex(cbindex>=1 & cbindex<=length(cmap)+1);

   % If there are just a few too many categories, still draw black
   % lines between color shades.  If there are a great deal too many (>31)
   % then remove the black lines where a tick label is also removed
   if length(Ytick)>31
    j=0;
    for i=cbindex
     j=j+1;
     newYtick(j)=Ytick(i);
     newYticklabel(j)=Yticklabel(i);
    end
   else
    newYticklabel=Yticklabel;
    newYtick=Ytick;
    for i=1:length(Yticklabel)
      newYticklabel(i)=NaN;
    end
    newYticklabel(cbindex)=Yticklabel(cbindex);
   end

   newYtick(1)=Ytick(1);
   newYtick(end)=Ytick(end);
   newYticklabel(1)=Yticklabel(1);
   newYticklabel(end)=Yticklabel(end);
   Ytick=newYtick;
   Yticklabel=newYticklabel;
   clear newYtick
   clear newYticklabel 

 end

 % Add exponent to colorbar to tidy it up
 if max(abs(cont))>=10000 | max(abs(cont))<=0.1
   factor=fix(log10(max(abs(cont))))-1;
   for i=1:length(Ytick)
    Yticklabel(i)=Yticklabel(i)/(10^factor);
   end
   if strcmp(interpreter,'latex')
    mult=['$\times\,10^{',num2str(factor),'}\;$'];
   else
    mult=['x 10^{',num2str(factor),'}'];
   end
 else
   mult=[''];
 end

end

% add units and factor of ten
xlim=get(hcb,'xlim');
ylim=get(hcb,'ylim');

% organize units and factor of ten
if strcmp(horiz,'vertical'); 
         if strcmpi(interpreter,'latex')
          if isempty(mult)         
           if iscell(units) & length(units)>2
            error('units can only be a cell array of length 2 or less')
           elseif iscell(units) & length(units)==2
            unitsdisplay={['$\mathrm{',char(units{1}),'}$'],...
                          ['$\mathrm{',char(units{2}),'}$']};
           else
            unitsdisplay={['$\mathrm{',char(units),'}$']};
           end
          else
           unitsdisplay={mult,['$\mathrm{',char(units),'}$']};
          end
         else
          if isempty(mult)         
           unitsdisplay={char(units)};
          else
           unitsdisplay={mult,units};
          end
         end
	 htt=text(xlim(1),ylim(1),unitsdisplay,'Interpreter',interpreter,...
         'Parent',hcb,'HorizontalAlign','left','VerticalAlign','top',...
         'fontsize',fontsize,'UserData','units','Margin',1);
         textextent=get(htt,'Extent');
         delete(htt);
	 htt=text(xlim(1),ylim(1)-0.33*textextent(4),unitsdisplay,...
         'Interpreter',interpreter,...
         'Parent',hcb,'HorizontalAlign','left','VerticalAlign','top',...
         'fontsize',fontsize,'UserData','units','Margin',1);
else
         if strcmpi(interpreter,'latex')
          unitsdisplay={['$\;\;$ ',mult,' $\mathrm{',char(units),'}$']};
         else
          unitsdisplay={['  ',mult,' ',char(units)]};
         end
	 htt=text(xlim(2),ylim(1),unitsdisplay,'Interpreter',interpreter,...
         'Parent',hcb,'HorizontalAlign','left','VerticalAlign','baseline',...
         'fontsize',fontsize,'UserData','units','Margin',1);
end

cbtext.type='units';
cbtext.extent=get(htt,'extent');
set(htt,'UserData',cbtext);

% convert the tick labels to text with identical precision
if isnumeric(loglin) % log scale

 newYticklabel=cell(length(Ytick),1);
 for i=1:length(Ytick);
  if Yticklabel(i)==0 
   newYticklabel{i}='0';
  elseif isnan(Yticklabel(i)) 
   newYticklabel{i}=' ';
  else
   newYticklabel{i}=[num2str(sign(Yticklabel(i))),'0^{',num2str(log10(abs(Yticklabel(i)))),'}'];
  end
 end

else % linear scale

 % maxchar is the number of decimal points in the colorbar key
 newYticklabel=cell(length(Ytick),1);
 maxchar(1:length(Ytick))=0;

 % check to see if decimal points are required 
 for i=1:length(Yticklabel)
  if Yticklabel(i)~=ref & ~isnan(Yticklabel(i))
   fraction=abs(Yticklabel(i)-fix(Yticklabel(i)));
   if(fraction<10*eps); 
    maxchar(i)=0;
   else
    maxchar(i)=max(maxchar(i),length(num2str(fraction))-2);
   end
  end
 end

 % set uniform maximum for linear color scales
 if strcmpi(loglin,'linear')
  maxc=max(maxchar);
  maxchar(1:end)=maxc;
 end

 % enshrine this in the tick labels
 for i=1:length(Yticklabel)
  if nargin<6
   if Yticklabel(i)==0
    newYticklabel{i}='0';
   elseif isnan(Yticklabel(i)) 
    newYticklabel{i}=' ';
   elseif Yticklabel(i)==ref
    newYticklabel{i}=num2str(ref);
   else
    newYticklabel{i}=num2str(Yticklabel(i),['%9.',num2str(maxchar(i)),'f']);
   end
  else
   newYticklabel{i}=colvals{i};
  end
 end

end

% remove upper and lower tick labels if they are not the reference value
arrb=[];
if Yticklabel(1)~=ref & nargin<6
  newYticklabel{1}=' ';
  if strcmp(horiz,'vertical') % draw lower arrow
   arrb=text(xlim(2),ylim(1),['$\;\downarrow$'],'Interpreter','Latex',...
     'Parent',hcb,'HorizontalAlign','left','VerticalAlign','bottom',...
     'fontsize',fontsize-1,'UserData','arrow');
  else
   arrb=text(xlim(1),ylim(1),['$\leftarrow$'],'Interpreter','Latex',...
     'Parent',hcb,'HorizontalAlign','left','VerticalAlign','cap',...
     'fontsize',fontsize-1,'UserData','arrow');
  end

  cbtext.type='arrow';
  cbtext.extent=get(arrb,'extent');
  set(arrb,'UserData',cbtext);

end

arrt=[];
if Yticklabel(length(Yticklabel))~=ref  & nargin<6
  newYticklabel{length(Yticklabel)}=' ';
  if strcmp(horiz,'vertical') % draw upper arrow
   arrt=text(xlim(2),ylim(2),['$\;\uparrow$'],'Interpreter','Latex',...
     'Parent',hcb,'HorizontalAlign','left','VerticalAlign','cap',...
     'fontsize',fontsize-1);
  else
   arrt=text(xlim(2),ylim(1),['$\rightarrow$'],'Interpreter','Latex',...
     'Parent',hcb,'HorizontalAlign','right','VerticalAlign','cap',...
     'fontsize',fontsize-1);
  end

  cbtext.type='arrow';
  cbtext.extent=get(arrt,'extent');
  set(arrt,'UserData',cbtext);

end


% write the tick labels and add box around each tick segment
if strcmp(horiz,'vertical');
 for i=1:length(Ytick)

  if strcmpi(interpreter,'latex')
   tickh=text(xlim(2),Ytick(i),['$\;\mathrm{',char(newYticklabel{i}),'}$'],...
         'Parent',hcb,'HorizontalAlign','left','VerticalAlign','middle',...
         'fontsize',fontsize,'Interpreter','Latex');
  else
   tickh=text(xlim(2),Ytick(i),[' ',char(newYticklabel{i})],...
         'Parent',hcb,'HorizontalAlign','left','VerticalAlign','middle',...
         'fontsize',fontsize);
  end
  

  cbtext.type='scale';
  cbtext.extent=get(tickh,'extent');
  set(tickh,'UserData',cbtext);

  if i==2 & ~strcmpi(char(newYticklabel{i}),' ') & ~isempty(arrb)

   htickh=get(tickh,'extent');
   harrb=get(arrb,'extent');
   overlap=max(0.,(harrb(2)+harrb(4))-htickh(2));

   if overlap>0 | maxticks<=11;
    delete(arrb)
    delete(arrt)
    arrb=text(xlim(2),ylim(1),['$\;\downarrow$'],'Interpreter','Latex',...
        'Parent',hcb,'HorizontalAlign','left','VerticalAlign','middle',...
        'fontsize',fontsize-1);

    cbtext.type='arrow';
    cbtext.extent=get(arrb,'extent');
    set(arrb,'UserData',cbtext);

    if ~isempty(arrt)

     arrt=text(xlim(2),ylim(2),['$\;\uparrow$'],'Interpreter','Latex',...
          'Parent',hcb,'HorizontalAlign','left','VerticalAlign','middle',...
          'fontsize',fontsize-1);

     cbtext.type='arrow';
     cbtext.extent=get(arrt,'extent');
     set(arrt,'UserData',cbtext);

    end
   end

  elseif i==length(Ytick)-1 & ~strcmpi(char(newYticklabel{i}),' ') & ~isempty(arrt)

   htickh=get(tickh,'extent');
   harrt=get(arrt,'extent');
   overlap=max(0.,(htickh(2)+htickh(4))-harrt(2));

   if overlap>0 | maxticks<=11;
    delete(arrb)
    delete(arrt)

    if ~isempty(arrb)

     arrb=text(xlim(2),ylim(1),['$\;\downarrow$'],'Interpreter','Latex',...
         'Parent',hcb,'HorizontalAlign','left','VerticalAlign','middle',...
         'fontsize',fontsize-1);

     cbtext.type='arrow';
     cbtext.extent=get(arrb,'extent');
     set(arrb,'UserData',cbtext);

    end

    arrt=text(xlim(2),ylim(2),['$\;\uparrow$'],'Interpreter','Latex',...
         'Parent',hcb,'HorizontalAlign','left','VerticalAlign','middle',...
         'fontsize',fontsize-1);

    cbtext.type='arrow';
    cbtext.extent=get(arrt,'extent');
    set(arrt,'UserData',cbtext);

   end

  end

  if i>1 
   hh=patch([xlim(1); xlim(1); xlim(2); xlim(2)],...
         [Ytick(i-1); Ytick(i); Ytick(i); Ytick(i-1)],...
         cmap(i-1,:),'FaceColor','none');

  end

 end
elseif strcmp(horiz,'horizontal');
 for i=1:length(Ytick)

  tickh=text(Ytick(i),ylim(1)-0.1*(abs(diff(ylim))),[char(newYticklabel{i})],...
       'Parent',hcb,'HorizontalAlign','center','VerticalAlign','cap',...
       'fontsize',fontsize-2);

  cbtext.type='scale';
  cbtext.extent=get(tickh,'extent');
  set(tickh,'UserData',cbtext);

  if i>1 
   hh=patch([Ytick(i-1); Ytick(i); Ytick(i); Ytick(i-1)],...
         [ylim(1); ylim(1); ylim(2); ylim(2)],...
         cmap(i-1,:),'FaceColor','none');
  end
 end
else
 error('Orientation problem with colorbar');
end

% add minor tick marks for logarithmic color scale
if isnumeric(loglin) & ~isempty(minortick) % log scale
 if strcmp(horiz,'vertical');
  xminortick=[xlim(1) xlim(1)+0.1*diff(xlim) NaN xlim(2)-0.1*diff(xlim) xlim(2)];
  for i=1:length(minortick)
   hll=line(xminortick,repmat(minortick(i),size(xminortick)),'Color','k');
   set(hll,'Parent',hcb);
  end
 elseif strcmp(horiz,'horizontal');
  yminortick=[ylim(1) ylim(1)+0.1*diff(ylim) NaN ylim(2)-0.1*diff(ylim) ylim(2)];
  for i=1:length(minortick)
   hll=line(repmat(minortick(i),size(yminortick)),yminortick,'Color','k');
   set(hll,'Parent',hcb);
  end
 else
  error('Orientation problem with colorbar');
 end
end

% stops subsequent overlays from changing the colorbar
set(ht,'CLimMode','manual')

% set current axis
set(gcf,'CurrentAxes',ht);

drawnow;

if debug; disp(['...Leaving ',mfilename]); end

